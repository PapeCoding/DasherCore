#pragma once

// Classes representing different event types.

#include <string>
#include <functional>

namespace Dasher {
  class CEditEvent;
  class CGameNodeDrawEvent;
  class CDasherNode; //fwd decl, avoid include...we just store ptr
}
/// \ingroup Core
/// @{

/// \defgroup Events Events generated by Dasher modules.
/// @{



class Dasher::CEditEvent {
public:
    enum EditEventType
    {
        EDIT_OUTPUT=1,
        EDIT_DELETE=2,
        EDIT_CONVERT=10,
        EDIT_PROTECT=11
    };

  CEditEvent(EditEventType iEditType, const std::string & sText, CDasherNode *pNode)
  : m_iEditType(iEditType), m_sText(sText), m_pNode(pNode) {
  }  
  const EditEventType m_iEditType;
  const std::string m_sText;
  /// Node causing the event - allows calling GetSymbolProb, offset(), etc.
  /// _if necessary_
  const CDasherNode *m_pNode;
};

/// @}
/// @}

// Simple Event Implementation, very similar to a Signal/Slot (Publisher/Subscriber) Pattern
template<typename... Args>
class Event
{
public:
    void Subscribe(void* Listener, const std::function<void(Args...)>& Function)
    {
        Listeners[Listener] = Function;
    }

    void Unsubscribe(void* Listener)
    {
        Listeners.erase(Listener);
    }

    void Clear(){Listeners.clear();}

    void Broadcast(Args... i)
    {
        for(auto& [key, value] : Listeners)
        {
            if(value) value(i...);
        }
    }

private:
    std::unordered_map<void*, std::function<void(Args...)>> Listeners;
};